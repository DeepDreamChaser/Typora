# 蓝桥杯笔记：

关于蓝桥杯的一些规划

**简单的题V有问题**

## 第一章：语言基础：

### 1.1 排序：



------

### 1.2 基础查找：



------

### 1.3 二分查找：





------

### 1.4 大小写转换：

**islower 和 isupper函数**

**含义：**

​		islower 和 isupper函数，用于判断这个字符**是否**属于**大写**或者**小写**字符，他们的函数返回值类型为bool。

- islower是用于判断当前的字符是否是小写字符，如果是，返回true，如果不是，则返回false。
- isupper是用于判断当前的字符是否是大写字符，如果是，返回true，如果不是，则返回false。

**tolower 和 toupper函数**

**含义：**

​		tolower函数 和 toupper函数分别是用于将**大写字符**和**小写字符**转换成为**小写字符**和**大写字符**的

- tolower函数用于将大写字符转换为小写字符
- toupper函数用于将小写字符转换为大写字符

**注意事项：要加上头文件**

#include <cctype>

*示例代码：*

```c++
#include <iostream>
#include <cctype>
using namespace std;
// islower 和 isupper函数，用于判断这个字符是否属于大写或者小写字符
// 函数返回值类型为bool
// tolower 和 toupper函数是用于转换字符成为小写或者大写的函数
char ch1 = 'A';
char ch2 = 'b';

// 使用islower函数判断是否为小写字符
int main() {
	if (islower(ch1)) {
		cout << ch1 << " is a lower letter." << endl;
	}
	else {
		cout << ch1 << " is not a lower letter." << endl;
	}

	// 使用isupper函数判断字符是否是大写
	if (isupper(ch2)) {
		cout << ch2 << " is a upper letter." << endl;
	
	}
	else {
		cout << ch2 << " is not a upper letter." << endl;
	}

	// 使用tolower和toupper函数来进行大小写的转换
	char lowcaseCh1 = tolower(ch1);			// ch1的小写‘a'
	char upcaseCh2 = toupper(ch2);			// ch2的大写‘B’

	cout << "Lowcase of " << ch1 << " is " << lowcaseCh1 << endl;
	cout << "upcase of " << ch2 << " is " << upcaseCh2 << endl;
	return 0;
}


```

*结果：*

```
A is not a lower letter.
b is not a upper letter.
Lowcase of A is a
upcase of b is B

E:\all_project\C++project\C++基础\Debug\testDemo3.exe (进程 25752)已退出，代码为 0 (0x0)。
要在调试停止时自动关闭控制台，请启用“工具”->“选项”->“调试”->“调试停止时自动关闭控制台”。
按任意键关闭此窗口. . .
```



*示例代码2：*

```c++
#include <iostream>
#include <cctype>	
#include <algorithm>
using namespace std;
// 转换大小写的函数 
char convertedCh(char ch){
	if(islower(ch)){		// 如果它是小写的话，转换为大写 
		ch = toupper(ch);
	}else if(isupper(ch)){	// 如果它是大写的话，转换为小写 
		ch = tolower(ch);	
	}
    // 也可以写成这个样子
    /*
    if(islower(ch)){		// 如果它是小写的话，转换为大写 
		ch = ch - 'a' + 'A';		// 跟toupper一个效果 
	}else if(isupper(ch)){	// 如果它是大写的话，转换为小写 
		ch = ch - 'A' + 'a';		// 跟tolower一个效果 
	}
    */
	return ch;
} 


int main()
{
	string s;
	getline(cin, s);
	for(auto &i : s){
		i = convertedCh(i);
	}
	cout << s << endl;
    return 0;
}
```

结果：

```C
Add
aDD

--------------------------------
Process exited after 2.773 seconds with return value 0
请按任意键继续. . .
```



**ASCII码：**

含义：

​		ASCII 码使用指定的7 位或8 位[二进制数](https://baike.baidu.com/item/二进制数/108101?fromModule=lemma_inlink)组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和[小写字母](https://baike.baidu.com/item/小写字母/4666069?fromModule=lemma_inlink)，数字0 到9、标点符号，以及在美式英语中使用的特殊[控制字符](https://baike.baidu.com/item/控制字符/6913704?fromModule=lemma_inlink) [1]。

![ASCII](E:\Typora笔记\算法\image\ASCII.jpeg)



**其中：**

**0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符）**

如控制符：[LF](https://baike.baidu.com/item/LF/306278?fromModule=lemma_inlink)(换行)、CR(回车)、FF(换页)、DEL(删除)、BS(退格)、BEL(响铃)等；

通信专用字符：SOH（[文头](https://baike.baidu.com/item/文头/1433457?fromModule=lemma_inlink)）、EOT（文尾）、[ACK](https://baike.baidu.com/item/ACK/3692629?fromModule=lemma_inlink)（确认）等；

ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的[图形显示](https://baike.baidu.com/item/图形显示/2612527?fromModule=lemma_inlink)，但会依不同的[应用程序](https://baike.baidu.com/item/应用程序/5985445?fromModule=lemma_inlink)，而对文本显示有不同的影响 [1]。

32～126(共95个)是字符(32是空格)，其中48～57为0到9十个[阿拉伯数字](https://baike.baidu.com/item/阿拉伯数字/426445?fromModule=lemma_inlink)。

65～90为26个大写[英文字母](https://baike.baidu.com/item/英文字母/6779426?fromModule=lemma_inlink)，97～122号为26个[小写](https://baike.baidu.com/item/小写/1769537?fromModule=lemma_inlink)英文字母，其余为一些标点符号、运算符号等。

同时还要注意，在标准ASCII中，其最高位(b7)用作[奇偶校验](https://baike.baidu.com/item/奇偶校验/8090811?fromModule=lemma_inlink)位。所谓奇[偶校验](https://baike.baidu.com/item/偶校验/1684334?fromModule=lemma_inlink)，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分[奇校验](https://baike.baidu.com/item/奇校验/1684279?fromModule=lemma_inlink)和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是[偶数](https://baike.baidu.com/item/偶数/403454?fromModule=lemma_inlink)，若非偶数，则在最高位b7添1 [1]。

后128个称为[扩展ASCII](https://baike.baidu.com/item/扩展ASCII/9882009?fromModule=lemma_inlink)码。许多基于[x86](https://baike.baidu.com/item/x86/6150538?fromModule=lemma_inlink)的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个[特殊符号](https://baike.baidu.com/item/特殊符号/6685714?fromModule=lemma_inlink)字符、[外来语](https://baike.baidu.com/item/外来语/2475423?fromModule=lemma_inlink)字母和[图形符号](https://baike.baidu.com/item/图形符号/5199427?fromModule=lemma_inlink) [1]。

​																																																	      **--源自百度百科**

我们在编写代码的时候也可以使用ASCII码表来进行大小写的转换和判断

------





### 1.5 全排列：

#### 1.5.1 next_permutation()

**含义：**

next_permutation 函数用于生成当前序列的下一个排列。它按照字典序对序列进行重新排列，如果存在下一个排列，则将当前序列更改为下一个排列，并返回true;如果当前序列已经是最后一个排列，则将序列更改为第一个排列，并返回 false。

**示例代码：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
// next_permutation
/*
	next_permutation 函数用于生成当前序列的下一个排列。它按照字典序对序列进行重新排列，
如果存在下一个排列，则将当前序列更改为下一个排列，并返回true;如果当前序列已经是最后一个
排列，则将序列更改为第一个排列，并返回 false。
*/

int main() {
	vector<int> nums = { 1, 2, 3 };
	cout << "Initial permutation:" << endl;
	for (int num : nums) {
		cout << num << " ";
	}
	cout << endl;
	// 生产下一个排列
	while (next_permutation(nums.begin(), nums.end())) {
		cout << "Next permutation: ";
		for (int num : nums) {
			cout << num << " ";
		}
		cout << endl;
	}

	return 0;
}


```

**结果：**

```
Initial permutation:
1 2 3
Next permutation: 1 3 2
Next permutation: 2 1 3
Next permutation: 2 3 1
Next permutation: 3 1 2
Next permutation: 3 2 1

E:\all_project\C++project\C++基础\Debug\testDemo3.exe (进程 4704)已退出，代码为 0 (0x0)。
要在调试停止时自动关闭控制台，请启用“工具”->“选项”->“调试”->“调试停止时自动关闭控制台”。
按任意键关闭此窗口. . .
```

#### 1.5.2：prev_permutation() 函数

含义：

​		prev_permutation函数与next_permutation函数相反，它用于生产当前序列的前一个序列 ，它按照字典序对序列进行重新排列，如果存在上一个排列，则将当前序列更改为上一个排列，并返回true。如果当前序列已经是第一个排列，则将序列更改为最后一个排列，并返回 false。

**示例代码：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


int main() {
	vector<int> nums = { 3, 2, 1 };
	cout << "Initial permutation:" << endl;
	for (int num : nums) {
		cout << num << " ";
	}
	cout << endl;
	// 生产下一个排列
	while (prev_permutation(nums.begin(), nums.end())) {
		cout << "Next permutation: ";
		for (int num : nums) {
			cout << num << " ";
		}
		cout << endl;
	}

	return 0;
}

```

结果如下：

```
Initial permutation:
3 2 1
Next permutation: 3 1 2
Next permutation: 2 3 1
Next permutation: 2 1 3
Next permutation: 1 3 2
Next permutation: 1 2 3

E:\all_project\C++project\C++基础\Debug\testDemo3.exe (进程 19916)已退出，代码为 0 (0x0)。
要在调试停止时自动关闭控制台，请启用“工具”->“选项”->“调试”->“调试停止时自动关闭控制台”。
按任意键关闭此窗口. . .
```









------

### 1.6 其他库函数：

#### 1.6.1: memset()函数

解释：

​		memset()是一个用于设置内存块值的函数它的原型定义在<cstring>头文件中，函数的声明如下：

```c++
void* memset(void* ptr, int value, size_t num);
```

1.ptr：指向要设置值的内存块的指针

2.value：要设置的值，每一个字节的值都是value

3.num：要设置的字节数

memset()函数将ptr指向的内存块的前num个字节设置为value的值，它返回一个指向ptr的指针，
memset()函数通常用于初始化内存块，将其设置为特定的值



注意事项：

memset函数对于非字符型数组可能会产生未定义行为，所以在进行初始化的时候，最好使用其他方法，比如for循环遍历。

示例代码：

```c++
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
// memset()，这个函数一般用于初始化数组的值，它一般接受三个参数 
// memset会将每一个byte设置为value，所以它最好不要用来给非字符的数组用来设置其它值 
int main() {
	
	char ch[5];		// 字符数组
	memset(ch, 65, sizeof(ch));		// 使用memset来初始化字符数组，65所对应的值是ASCII码表所对应的值A 
	for(int i = 0; i < 5; i++){		// 初始化完输出 
		cout << ch[i] << endl;
	}
	
	// 应用到int数组中 
	int a[5];
	memset(a, 0, sizeof(a));		// 将所有的值初始化为0 
	for(int i = 0; i < 5; i++){
		cout << a[i] << endl;
	}
	
	// 但是，当我们使用其它值来进行定义的话，可能在int数组中不适用
	int b[5];
	memset(b, 1, sizeof(b));		// 将所有的值初始化，但是这个值是00000001000000010000000100000001(16843009)，
	// 因为它初始化每一个字节，而int有四个字节，不过，如果使用-1进行初始化是可以的 
	for(int i = 0; i < 5; i++){
		cout << b[i] << endl;
	}
	
	// -1数组 
	int c[5];
	memset(c, -1, sizeof(c));		// 将所有的值初始化为-1，这个是可以正常显示的，因为整数在系统中以补码的方式进行保存 
	for(int i = 0; i < 5; i++){
		cout << c[i] << endl;
	}
	
	/*
	总结：使用memset来初始化整数数组时，除了将数组初始化为全0或将每个元素初始化为-1之外，
	通常应该避免使用其他值。对于其他值，最好使用循环或其他初始化方法。最好是在字符数组中使用
	memset方法 
	*/ 
    return 0;
}
```

结果如下：

```
A
A
A
A
A
0
0
0
0
0
16843009
16843009
16843009
16843009
16843009
-1
-1
-1
-1
-1

--------------------------------
Process exited after 0.04169 seconds with return value 0
请按任意键继续. . .
```





## 第二章：基础算法：

### 1、时间复杂度



**时间复杂度概念**

- 时间复杂度是衡量算法执行时间随输入规模增长的增长率
- 我们通过算法中基本操作的执行次数来确定时间复杂度
- 常见的时间复杂度包括：常数时间O(1)、线性时间O(n)、对数时间O(logN)、平方时间O(n^2)等。
- 在计算时，我们只需要考虑复杂度的最大数量级，不用考虑其他， 比如O(2N) 一般用O(N)表示，O(N^2 * logN) 用 O(N^2)表示









**蓝桥题目3227（找到最多的数）：**

#### 问题描述

在一个 n×m*n*×*m* 的矩阵中，有一个数字出现了超过一半的次数，请设计一个高效算法找到这个数字。

#### 输入格式

输入第一行包含两个整数 n*n* 和 m*m*，表示矩阵的大小 (1≤n,m≤103)(1≤*n*,*m*≤103)。

接下来 n*n* 行，每行包含 m*m* 个正整数，表示矩阵中的元素。

#### 输出格式

输出一个整数，表示矩阵中出现次数超过一半的数字。

#### 样例输入

```
3 3
1 2 3
2 2 2
1 2 2
```

#### 样例输出

```
2
```

解题思路：

1、利用map函数来统计每一个数字的次数

代码：

```c++
#include <iostream>
#include <map>
using namespace std;
int main()
{
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);		// 用于提高性能
  int n, m, temp;
  map<int, int> result;   // 建立键值对，用于统计每一个数值出现的次数
  cin >> n >> m;
  // 进行二维数组的输入
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      cin >> temp;    // 输入当前位置的值
      result[temp]++;      // 利用map进行统计
    }
  }

  for(auto it = result.begin(); it != result.end(); it++){    // 对map容器进行遍历
    if(it->second > n * m / 2){   // 如果这个数组中出现的值超过了一半的次数，就输出该值
      cout << it->first;
    }
  }
  
  // 请在此输入您的代码
  return 0;
}
```

其中：

**`ios::sync_with_stdio(0)`**：
这个语句用于取消C++的iostream库与C的stdio库之间的同步。

**`cin.tie(0)`**

通过`cin.tie(0)`，我们解除了`cin`和`cout`之间的绑定，从而允许它们独立地工作，进一步提高性能。

**`cout.tie(0)`**

由于`cin`和`cout`默认是绑定的，且`cin.tie(0)`已经解除了这种绑定，因此通常不需要单独设置`cout.tie(0)`

另一种写法：

```c++
#include <iostream>
#include <map>
using namespace std;
int main()
{
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  int n, m, temp;
  map<int, int> result;   // 建立键值对，用于统计每一个数值出现的次数
  cin >> n >> m;
  // 进行遍历，统计他们的值出现次数
  for(int i = 0; i < n*m; i++){
    int x;
    cin >> x;
    result[x]++;
  }

  for(auto it = result.begin(); it != result.end(); it++){    // 对map容器进行遍历
    if(it->second > n * m / 2){   // 如果这个数组中出现的值超过了一半的次数，就输出该值
      cout << it->first;
    }
  }
  
  // 请在此输入您的代码
  return 0;
}
```





### 2、前缀和

概念：

前缀和是指某序列的前n项和， 可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。



 nums[d]< nums[c] < nums[a] < nums[b]



